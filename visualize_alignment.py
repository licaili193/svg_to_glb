#!/usr/bin/env python3
"""
Coordinate Alignment Visualizer

This program loads the PNG and SVG files generated by the OSMD renderer
and visualizes them to demonstrate exact coordinate matching.
"""

import matplotlib.pyplot as plt
import matplotlib.patches as patches
from PIL import Image
import numpy as np
import argparse
import os
from pathlib import Path

# Try to import SVG handling libraries
try:
    import cairosvg
    import io
    CAIROSVG_AVAILABLE = True
except (ImportError, OSError) as e:
    CAIROSVG_AVAILABLE = False
    if "cairo" in str(e).lower():
        print("Note: Cairo graphics library not available. Install with: brew install cairo (macOS)")
    else:
        print("Note: cairosvg not available. Install with: pip install cairosvg")

try:
    import xml.etree.ElementTree as ET
    XML_AVAILABLE = True
except ImportError:
    XML_AVAILABLE = False

class CoordinateVisualizer:
    def __init__(self, png_path, svg_path):
        self.png_path = Path(png_path)
        self.svg_path = Path(svg_path)
        
        if not self.png_path.exists():
            raise FileNotFoundError(f"PNG file not found: {png_path}")
        if not self.svg_path.exists():
            raise FileNotFoundError(f"SVG file not found: {svg_path}")
    
    def load_png(self):
        """Load PNG image and return as numpy array"""
        png_image = Image.open(self.png_path)
        return np.array(png_image)
    
    def load_svg_as_image(self, target_width, target_height):
        """Convert SVG to image array matching PNG dimensions"""
        if not CAIROSVG_AVAILABLE:
            print("Warning: Cannot render SVG as image - cairosvg not available")
            return None
        
        try:
            # Read SVG content
            with open(self.svg_path, 'r', encoding='utf-8') as f:
                svg_content = f.read()
            
            # Convert SVG to PNG bytes
            png_bytes = cairosvg.svg2png(
                bytestring=svg_content.encode('utf-8'),
                output_width=target_width,
                output_height=target_height
            )
            
            # Convert to PIL Image then numpy array
            svg_image = Image.open(io.BytesIO(png_bytes))
            return np.array(svg_image)
            
        except Exception as e:
            print(f"Error converting SVG to image: {e}")
            return None
    
    def extract_svg_info(self):
        """Extract basic info from SVG file"""
        if not XML_AVAILABLE:
            return None
        
        try:
            tree = ET.parse(self.svg_path)
            root = tree.getroot()
            
            info = {
                'width': root.get('width'),
                'height': root.get('height'),
                'viewBox': root.get('viewBox'),
                'element_count': len(list(root.iter()))
            }
            
            return info
        except Exception as e:
            print(f"Error reading SVG info: {e}")
            return None
    
    def create_comparison_plot(self):
        """Create a comprehensive comparison visualization"""
        # Load PNG
        png_data = self.load_png()
        png_height, png_width = png_data.shape[:2]
        
        print(f"PNG dimensions: {png_width} x {png_height}")
        
        # Get SVG info
        svg_info = self.extract_svg_info()
        if svg_info:
            print(f"SVG info: {svg_info}")
        
        # Try to load SVG as image
        svg_data = self.load_svg_as_image(png_width, png_height)
        
        # Create the visualization
        if svg_data is not None:
            # Case 1: Both images available - show comparison
            fig, axes = plt.subplots(2, 2, figsize=(16, 12))
            fig.suptitle('PNG vs SVG Coordinate Alignment Verification', fontsize=16, fontweight='bold')
            
            # Show PNG
            axes[0, 0].imshow(png_data)
            axes[0, 0].set_title('PNG Image')
            axes[0, 0].set_xlabel(f'Width: {png_width}px')
            axes[0, 0].set_ylabel(f'Height: {png_height}px')
            
            # Show SVG rendered as image
            axes[0, 1].imshow(svg_data)
            axes[0, 1].set_title('SVG Rendered as Image')
            axes[0, 1].set_xlabel(f'Width: {png_width}px')
            axes[0, 1].set_ylabel(f'Height: {png_height}px')
            
            # Show overlay (PNG with transparency over SVG)
            axes[1, 0].imshow(svg_data)
            axes[1, 0].imshow(png_data, alpha=0.5)
            axes[1, 0].set_title('Overlay: PNG (50% transparent) over SVG')
            axes[1, 0].set_xlabel('Perfect alignment = identical appearance')
            
            # Show difference map
            if png_data.shape == svg_data.shape:
                # Convert to grayscale for comparison
                png_gray = np.mean(png_data, axis=2) if len(png_data.shape) == 3 else png_data
                svg_gray = np.mean(svg_data, axis=2) if len(svg_data.shape) == 3 else svg_data
                
                diff = np.abs(png_gray.astype(float) - svg_gray.astype(float))
                
                im = axes[1, 1].imshow(diff, cmap='hot')
                axes[1, 1].set_title('Difference Map (Hot = Different)')
                axes[1, 1].set_xlabel('Dark areas = Perfect match')
                plt.colorbar(im, ax=axes[1, 1])
                
                # Calculate alignment statistics
                total_pixels = diff.size
                matching_pixels = np.sum(diff < 1)  # Allow for minor rounding differences
                match_percentage = (matching_pixels / total_pixels) * 100
                
                print(f"\nAlignment Statistics:")
                print(f"Total pixels: {total_pixels:,}")
                print(f"Matching pixels: {matching_pixels:,}")
                print(f"Match percentage: {match_percentage:.2f}%")
                
                # Add statistics to plot
                stats_text = f"Pixel Match: {match_percentage:.1f}%\nTotal Pixels: {total_pixels:,}"
                axes[1, 1].text(0.02, 0.98, stats_text, transform=axes[1, 1].transAxes, 
                               verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
            
        else:
            # Case 2: Only PNG available
            fig, axes = plt.subplots(1, 2, figsize=(16, 6))
            fig.suptitle('PNG and SVG File Information', fontsize=16, fontweight='bold')
            
            # Show PNG
            axes[0].imshow(png_data)
            axes[0].set_title('PNG Image')
            axes[0].set_xlabel(f'Width: {png_width}px')
            axes[0].set_ylabel(f'Height: {png_height}px')
            
            # Show file info
            axes[1].axis('off')
            info_text = f"PNG File: {self.png_path.name}\n"
            info_text += f"Dimensions: {png_width} x {png_height}\n"
            info_text += f"Size: {self.png_path.stat().st_size / 1024:.1f} KB\n\n"
            
            info_text += f"SVG File: {self.svg_path.name}\n"
            if svg_info:
                info_text += f"SVG Width: {svg_info['width']}\n"
                info_text += f"SVG Height: {svg_info['height']}\n"
                info_text += f"ViewBox: {svg_info['viewBox']}\n"
                info_text += f"Elements: {svg_info['element_count']}\n"
            
            info_text += f"Size: {self.svg_path.stat().st_size / 1024:.1f} KB\n\n"
            info_text += "Note: Install cairosvg for visual comparison:\n"
            info_text += "pip install cairosvg"
            
            axes[1].text(0.05, 0.95, info_text, transform=axes[1].transAxes, 
                        verticalalignment='top', fontfamily='monospace', fontsize=12)
            axes[1].set_title('File Information')
        
        # Add coordinate grid overlay to help verify alignment
        for ax in fig.get_axes():
            if hasattr(ax, 'imshow'):
                # Add grid lines every 500 pixels
                if png_width > 1000:
                    for x in range(0, png_width, 500):
                        ax.axvline(x, color='red', alpha=0.3, linewidth=0.5)
                    for y in range(0, png_height, 100):
                        ax.axhline(y, color='red', alpha=0.3, linewidth=0.5)
        
        plt.tight_layout()
        return fig
    
    def create_coordinate_test(self):
        """Create a detailed coordinate system test"""
        png_data = self.load_png()
        png_height, png_width = png_data.shape[:2]
        
        fig, ax = plt.subplots(1, 1, figsize=(16, 8))
        
        # Display the PNG
        ax.imshow(png_data)
        
        # Add coordinate markers at key points
        marker_points = [
            (0, 0, "Origin (0,0)"),
            (png_width-1, 0, f"Top-right ({png_width-1},0)"),
            (0, png_height-1, f"Bottom-left (0,{png_height-1})"),
            (png_width-1, png_height-1, f"Bottom-right ({png_width-1},{png_height-1})"),
            (png_width//2, png_height//2, f"Center ({png_width//2},{png_height//2})")
        ]
        
        for x, y, label in marker_points:
            ax.plot(x, y, 'ro', markersize=8)
            ax.annotate(label, (x, y), xytext=(10, 10), textcoords='offset points',
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7),
                       arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
        
        # Add scale references
        ax.set_xlabel('X Coordinate (pixels)', fontsize=12)
        ax.set_ylabel('Y Coordinate (pixels)', fontsize=12)
        ax.set_title(f'Coordinate System Verification - {png_width}x{png_height} pixels', fontsize=14, fontweight='bold')
        
        # Add grid
        ax.grid(True, alpha=0.3)
        ax.set_xlim(-50, png_width + 50)
        ax.set_ylim(png_height + 50, -50)  # Invert Y axis to match image coordinates
        
        return fig

def main():
    parser = argparse.ArgumentParser(
        description="Visualize PNG and SVG coordinate alignment",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python visualize_alignment.py output/music.png output/music.svg
  python visualize_alignment.py --png output/music.png --svg output/music.svg
  python visualize_alignment.py -p test_output/music.png -s test_output/music.svg --save alignment_check.png
        """
    )
    
    # Allow both positional and named arguments
    parser.add_argument('png_path', nargs='?', help='Path to PNG file')
    parser.add_argument('svg_path', nargs='?', help='Path to SVG file')
    parser.add_argument('--png', '-p', help='Path to PNG file (alternative to positional)')
    parser.add_argument('--svg', '-s', help='Path to SVG file (alternative to positional)')
    parser.add_argument('--save', help='Save comparison plot to file')
    parser.add_argument('--coordinate-test', action='store_true', help='Show coordinate system test')
    
    args = parser.parse_args()
    
    # Determine file paths
    png_path = args.png or args.png_path
    svg_path = args.svg or args.svg_path
    
    # Default paths if none provided
    if not png_path or not svg_path:
        if os.path.exists('output/music.png') and os.path.exists('output/music.svg'):
            png_path = png_path or 'output/music.png'
            svg_path = svg_path or 'output/music.svg'
            print(f"Using default files:")
            print(f"  PNG: {png_path}")
            print(f"  SVG: {svg_path}")
        else:
            print("Error: PNG and SVG paths must be provided or default files must exist in output/")
            print("Usage: python visualize_alignment.py <png_path> <svg_path>")
            return 1
    
    try:
        visualizer = CoordinateVisualizer(png_path, svg_path)
        
        print("Loading and analyzing files...")
        print("=" * 50)
        
        if args.coordinate_test:
            fig = visualizer.create_coordinate_test()
            plt.show()
        else:
            fig = visualizer.create_comparison_plot()
            
            if args.save:
                print(f"Saving comparison plot to: {args.save}")
                fig.savefig(args.save, dpi=150, bbox_inches='tight')
            
            plt.show()
        
        print("\n" + "=" * 50)
        print("✅ Visualization complete!")
        print("If the images overlay perfectly, coordinates are exactly aligned.")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main()) 